import os, json, subprocess, threading, time, pathlib
from flask import Flask, jsonify, send_file, request
from flask_cors import CORS

BASE_DIR = pathlib.Path(__file__).resolve().parent
OUTPUT_PATH = BASE_DIR / "output.json"
LOGS_DIR = BASE_DIR / "logs"
LOGS_DIR.mkdir(exist_ok=True)

app = Flask(__name__)
CORS(app, resources={r"/*": {"origins": "*"}})

def _read_json_safe(path: pathlib.Path):
    if not path.exists():
        return None, "output.json not found"
    try:
        with path.open("r", encoding="utf-8") as f:
            data = json.load(f)
        return data, None
    except Exception as e:
        return None, f"Invalid JSON: {e}"

@app.get("/")
def index():
    return jsonify({
        "service": "content-automation-backend",
        "status": "ok",
        "endpoints": ["/health", "/output.json", "/version", "/run (POST)", "/push (POST)"]
    })

@app.get("/health")
def health():
    data, err = _read_json_safe(OUTPUT_PATH)
    return jsonify({
        "ok": True,
        "has_output_json": OUTPUT_PATH.exists(),
        "json_valid": err is None,
        "error": err
    })

@app.get("/output.json")
def get_output():
    if not OUTPUT_PATH.exists():
        return jsonify({"error": "output.json not found"}), 404
    # Also sets proper JSON MIME and lets Android app fetch it
    return send_file(str(OUTPUT_PATH), mimetype="application/json")

@app.get("/version")
def version():
    # Try to read git commit; fall back to env or unknown
    commit = os.environ.get("RENDER_GIT_COMMIT") or os.environ.get("GIT_COMMIT", "")
    try:
        # This may fail on Render if .git is not present; that's fine.
        rev = subprocess.check_output(["git", "rev-parse", "--short", "HEAD"], cwd=str(BASE_DIR)).decode().strip()
        commit = commit or rev
    except Exception:
        pass
    return jsonify({"commit": commit or "unknown"})

def _run_script(cmd: list[str], log_name: str, timeout_sec: int = 900):
    """
    Run a Python script (e.g., main.py or push_to_github.py) in a thread with timeout.
    Returns tuple (ok, tail_log_text).
    """
    log_file = LOGS_DIR / log_name
    start = time.time()
    with log_file.open("w", encoding="utf-8") as lf:
        try:
            proc = subprocess.Popen(
                cmd,
                cwd=str(BASE_DIR),
                stdout=lf, stderr=subprocess.STDOUT,
                env={**os.environ}
            )
            while proc.poll() is None:
                if time.time() - start > timeout_sec:
                    proc.kill()
                    lf.write("\n\n[ERROR] Process timeout â€” killed.\n")
                    return False, _tail(log_file)
                time.sleep(0.5)
            ok = (proc.returncode == 0)
            return ok, _tail(log_file)
        except Exception as e:
            lf.write(f"\n\n[ERROR] Exception: {e}\n")
            return False, _tail(log_file)

def _tail(path: pathlib.Path, n: int = 2000) -> str:
    try:
        text = path.read_text(encoding="utf-8", errors="ignore")
        # Keep last ~4000 chars to avoid huge payloads
        return text[-4000:]
    except Exception:
        return ""

@app.post("/run")
def run_pipeline():
    """
    Runs your pipeline: python main.py
    Returns 200 with log tail on success, 500 on failure.
    NOTE: Long operations can hit platform timeouts; keep your pipeline efficient.
    """
    ok, log_tail = _run_script(["python", "main.py"], "run_main.log", timeout_sec=900)
    status = 200 if ok else 500
    data, err = _read_json_safe(OUTPUT_PATH)
    return jsonify({
        "ok": ok,
        "log_tail": log_tail,
        "has_output_json": OUTPUT_PATH.exists(),
        "json_valid": err is None,
        "error": err
    }), status

@app.post("/push")
def push_to_github():
    """
    Push latest files (incl. output.json) to GitHub using GH_TOKEN.
    """
    ok, log_tail = _run_script(["python", "push_to_github.py"], "push_to_github.log", timeout_sec=300)
    status = 200 if ok else 500
    return jsonify({"ok": ok, "log_tail": log_tail}), status

def _create_app():
    return app

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.environ.get("PORT", "5000")))
